package github

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/google/go-github/v74/github"
)

// Security Operations - Code Scanning, Dependabot, Secret Scanning

// ListCodeScanningAlertsHandler handles listing code scanning alerts
type ListCodeScanningAlertsHandler struct {
	provider *GitHubProvider
}

func NewListCodeScanningAlertsHandler(p *GitHubProvider) *ListCodeScanningAlertsHandler {
	return &ListCodeScanningAlertsHandler{provider: p}
}

func (h *ListCodeScanningAlertsHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "list_code_scanning_alerts",
		Description: "List code scanning security alerts for a repository, showing potential vulnerabilities found by static analysis",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"state": map[string]interface{}{
					"type":        "string",
					"description": "Filter alerts by state",
					"enum":        []interface{}{"open", "closed", "dismissed", "fixed"},
					"example":     "open",
				},
				"ref": map[string]interface{}{
					"type":        "string",
					"description": "Git reference to filter alerts (branch name, tag, or full commit SHA)",
					"example":     "main",
				},
				"per_page": map[string]interface{}{
					"type":        "integer",
					"description": "Number of alerts to return per page (1-100)",
					"default":     30,
					"minimum":     1,
					"maximum":     100,
					"example":     50,
				},
				"page": map[string]interface{}{
					"type":        "integer",
					"description": "Page number to retrieve (1-based pagination)",
					"default":     1,
					"minimum":     1,
					"example":     1,
				},
			},
			"required": []interface{}{"owner", "repo"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events", "repo"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"alerts": []map[string]interface{}{
				{
					"number":     1,
					"state":      "open",
					"rule":       map[string]interface{}{"id": "js/sql-injection", "severity": "error", "description": "Database query built from user-controlled sources"},
					"tool":       map[string]interface{}{"name": "CodeQL", "version": "2.0.0"},
					"created_at": "2024-01-15T12:00:00Z",
					"html_url":   "https://github.com/owner/repo/security/code-scanning/1",
				},
			},
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the owner and repo names are correct, and that code scanning is enabled for the repository.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and read access to the repository.",
			},
		},
		ExtendedHelp: "Lists code scanning alerts generated by static analysis tools like CodeQL. These alerts identify potential security vulnerabilities and code quality issues. Requires code scanning to be enabled and configured in the repository.",
	}
}

func (h *ListCodeScanningAlertsHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")

	pagination := ExtractPagination(params)
	opts := &github.AlertListOptions{
		ListOptions: github.ListOptions{
			Page:    pagination.Page,
			PerPage: pagination.PerPage,
		},
	}

	if state := extractString(params, "state"); state != "" {
		opts.State = state
	}
	if ref := extractString(params, "ref"); ref != "" {
		opts.Ref = ref
	}

	alerts, _, err := client.CodeScanning.ListAlertsForRepo(ctx, owner, repo, opts)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to list code scanning alerts: %v", err)), nil
	}

	data, _ := json.Marshal(alerts)
	return NewToolResult(string(data)), nil
}

// GetCodeScanningAlertHandler handles getting a specific code scanning alert
type GetCodeScanningAlertHandler struct {
	provider *GitHubProvider
}

func NewGetCodeScanningAlertHandler(p *GitHubProvider) *GetCodeScanningAlertHandler {
	return &GetCodeScanningAlertHandler{provider: p}
}

func (h *GetCodeScanningAlertHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "get_code_scanning_alert",
		Description: "Get detailed information about a specific code scanning security alert",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"alert_number": map[string]interface{}{
					"type":        "integer",
					"description": "The number that identifies the alert (get from list_code_scanning_alerts)",
					"example":     42,
					"minimum":     1,
				},
			},
			"required": []interface{}{"owner", "repo", "alert_number"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events", "repo"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"number":     42,
			"state":      "open",
			"rule":       map[string]interface{}{"id": "js/sql-injection", "severity": "error"},
			"tool":       map[string]interface{}{"name": "CodeQL"},
			"instances":  []map[string]interface{}{{"location": map[string]interface{}{"path": "src/db.js", "start_line": 15}}},
			"created_at": "2024-01-15T12:00:00Z",
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the alert_number exists. Use list_code_scanning_alerts to find valid alert numbers.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and read access to the repository.",
			},
		},
		ExtendedHelp: "Retrieves detailed information about a specific code scanning alert, including the rule that triggered it, affected code locations, and current state. Use this to investigate and triage security vulnerabilities.",
	}
}

func (h *GetCodeScanningAlertHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")
	alertNumber := int64(extractInt(params, "alert_number"))

	alert, _, err := client.CodeScanning.GetAlert(ctx, owner, repo, alertNumber)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to get code scanning alert: %v", err)), nil
	}

	data, _ := json.Marshal(alert)
	return NewToolResult(string(data)), nil
}

// UpdateCodeScanningAlertHandler handles updating a code scanning alert
type UpdateCodeScanningAlertHandler struct {
	provider *GitHubProvider
}

func NewUpdateCodeScanningAlertHandler(p *GitHubProvider) *UpdateCodeScanningAlertHandler {
	return &UpdateCodeScanningAlertHandler{provider: p}
}

func (h *UpdateCodeScanningAlertHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "update_code_scanning_alert",
		Description: "Update a code scanning alert status to dismiss or reopen it with explanatory context",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"alert_number": map[string]interface{}{
					"type":        "integer",
					"description": "The number that identifies the alert to update",
					"example":     42,
					"minimum":     1,
				},
				"state": map[string]interface{}{
					"type":        "string",
					"description": "New state for the alert",
					"enum":        []interface{}{"open", "dismissed"},
					"example":     "dismissed",
				},
				"dismissed_reason": map[string]interface{}{
					"type":        "string",
					"description": "Reason for dismissing the alert (required when state is 'dismissed')",
					"enum":        []interface{}{"false_positive", "wont_fix", "used_in_tests"},
					"example":     "false_positive",
				},
				"dismissed_comment": map[string]interface{}{
					"type":        "string",
					"description": "Optional comment explaining why the alert was dismissed",
					"example":     "This is a test file and the vulnerability is intentional for demonstration",
					"maxLength":   280,
				},
			},
			"required": []interface{}{"owner", "repo", "alert_number", "state"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"number":           42,
			"state":            "dismissed",
			"dismissed_by":     map[string]interface{}{"login": "octocat"},
			"dismissed_at":     "2024-01-15T12:30:00Z",
			"dismissed_reason": "false_positive",
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the alert_number exists. Use list_code_scanning_alerts to find valid alert numbers.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and write access to dismiss alerts.",
			},
			{
				"error":    "422 Unprocessable Entity",
				"solution": "When dismissing, ensure dismissed_reason is provided. Check that the state transition is valid.",
			},
		},
		ExtendedHelp: "Updates the state of a code scanning alert. Use this to dismiss false positives or alerts that won't be fixed, or to reopen previously dismissed alerts. Dismissal reasons help track why alerts were closed without fixing.",
	}
}

func (h *UpdateCodeScanningAlertHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")
	alertNumber := int64(extractInt(params, "alert_number"))
	state := extractString(params, "state")

	opts := &github.CodeScanningAlertState{
		State: state,
	}

	if reason := extractString(params, "dismissed_reason"); reason != "" {
		opts.DismissedReason = &reason
	}
	if comment := extractString(params, "dismissed_comment"); comment != "" {
		opts.DismissedComment = &comment
	}

	alert, _, err := client.CodeScanning.UpdateAlert(ctx, owner, repo, alertNumber, opts)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to update code scanning alert: %v", err)), nil
	}

	data, _ := json.Marshal(alert)
	return NewToolResult(string(data)), nil
}

// ListDependabotAlertsHandler handles listing Dependabot alerts
type ListDependabotAlertsHandler struct {
	provider *GitHubProvider
}

func NewListDependabotAlertsHandler(p *GitHubProvider) *ListDependabotAlertsHandler {
	return &ListDependabotAlertsHandler{provider: p}
}

func (h *ListDependabotAlertsHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "list_dependabot_alerts",
		Description: "List Dependabot security alerts for vulnerable dependencies in a repository",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"state": map[string]interface{}{
					"type":        "string",
					"description": "Filter alerts by state",
					"enum":        []interface{}{"open", "dismissed", "fixed"},
					"example":     "open",
				},
				"severity": map[string]interface{}{
					"type":        "string",
					"description": "Filter alerts by severity level",
					"enum":        []interface{}{"low", "medium", "high", "critical"},
					"example":     "high",
				},
				"ecosystem": map[string]interface{}{
					"type":        "string",
					"description": "Filter by package ecosystem",
					"enum":        []interface{}{"npm", "pip", "maven", "nuget", "composer", "go", "rust", "rubygems"},
					"example":     "npm",
				},
				"per_page": map[string]interface{}{
					"type":        "integer",
					"description": "Number of alerts to return per page (1-100)",
					"default":     30,
					"minimum":     1,
					"maximum":     100,
					"example":     50,
				},
				"page": map[string]interface{}{
					"type":        "integer",
					"description": "Page number to retrieve (1-based pagination)",
					"default":     1,
					"minimum":     1,
					"example":     1,
				},
			},
			"required": []interface{}{"owner", "repo"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events", "repo"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"alerts": []map[string]interface{}{
				{
					"number":            1,
					"state":             "open",
					"dependency":        map[string]interface{}{"package": map[string]interface{}{"ecosystem": "npm", "name": "lodash"}},
					"security_advisory": map[string]interface{}{"severity": "high", "summary": "Prototype Pollution"},
					"created_at":        "2024-01-15T12:00:00Z",
				},
			},
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the repository exists and Dependabot is enabled.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and read access to the repository.",
			},
		},
		ExtendedHelp: "Lists Dependabot alerts for known vulnerabilities in dependencies. These alerts help identify and fix security vulnerabilities in third-party packages. Requires Dependabot to be enabled in the repository settings.",
	}
}

func (h *ListDependabotAlertsHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")

	pagination := ExtractPagination(params)
	opts := &github.ListAlertsOptions{
		ListOptions: github.ListOptions{
			Page:    pagination.Page,
			PerPage: pagination.PerPage,
		},
	}

	if state := extractString(params, "state"); state != "" {
		opts.State = &state
	}
	if severity := extractString(params, "severity"); severity != "" {
		opts.Severity = &severity
	}
	if ecosystem := extractString(params, "ecosystem"); ecosystem != "" {
		opts.Ecosystem = &ecosystem
	}

	alerts, _, err := client.Dependabot.ListRepoAlerts(ctx, owner, repo, opts)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to list Dependabot alerts: %v", err)), nil
	}

	data, _ := json.Marshal(alerts)
	return NewToolResult(string(data)), nil
}

// GetDependabotAlertHandler handles getting a specific Dependabot alert
type GetDependabotAlertHandler struct {
	provider *GitHubProvider
}

func NewGetDependabotAlertHandler(p *GitHubProvider) *GetDependabotAlertHandler {
	return &GetDependabotAlertHandler{provider: p}
}

func (h *GetDependabotAlertHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "get_dependabot_alert",
		Description: "Get detailed information about a specific Dependabot security alert",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"alert_number": map[string]interface{}{
					"type":        "integer",
					"description": "The number that identifies the Dependabot alert",
					"example":     1,
					"minimum":     1,
				},
			},
			"required": []interface{}{"owner", "repo", "alert_number"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events", "repo"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"number":     1,
			"state":      "open",
			"dependency": map[string]interface{}{"package": map[string]interface{}{"ecosystem": "npm", "name": "lodash", "version": "4.17.20"}},
			"security_advisory": map[string]interface{}{
				"ghsa_id":     "GHSA-xxxxx",
				"severity":    "high",
				"summary":     "Prototype Pollution in lodash",
				"description": "Versions of lodash prior to 4.17.21 are vulnerable to Prototype Pollution",
			},
			"vulnerable_version_range": "< 4.17.21",
			"first_patched_version":    map[string]interface{}{"identifier": "4.17.21"},
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the alert_number exists. Use list_dependabot_alerts to find valid alert numbers.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and read access to the repository.",
			},
		},
		ExtendedHelp: "Retrieves comprehensive details about a Dependabot alert including the vulnerable dependency, security advisory information, affected versions, and available fixes. Use this to understand the vulnerability and plan remediation.",
	}
}

func (h *GetDependabotAlertHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")
	alertNumber := extractInt(params, "alert_number")

	alert, _, err := client.Dependabot.GetRepoAlert(ctx, owner, repo, alertNumber)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to get Dependabot alert: %v", err)), nil
	}

	data, _ := json.Marshal(alert)
	return NewToolResult(string(data)), nil
}

// UpdateDependabotAlertHandler handles updating a Dependabot alert
type UpdateDependabotAlertHandler struct {
	provider *GitHubProvider
}

func NewUpdateDependabotAlertHandler(p *GitHubProvider) *UpdateDependabotAlertHandler {
	return &UpdateDependabotAlertHandler{provider: p}
}

func (h *UpdateDependabotAlertHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "update_dependabot_alert",
		Description: "Update a Dependabot alert status to dismiss or reopen it with explanatory context",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"alert_number": map[string]interface{}{
					"type":        "integer",
					"description": "The number that identifies the Dependabot alert to update",
					"example":     1,
					"minimum":     1,
				},
				"state": map[string]interface{}{
					"type":        "string",
					"description": "New state for the alert",
					"enum":        []interface{}{"open", "dismissed"},
					"example":     "dismissed",
				},
				"dismissed_reason": map[string]interface{}{
					"type":        "string",
					"description": "Reason for dismissing the alert (required when state is 'dismissed')",
					"enum":        []interface{}{"fix_started", "inaccurate", "no_bandwidth", "not_used", "tolerable_risk"},
					"example":     "tolerable_risk",
				},
				"dismissed_comment": map[string]interface{}{
					"type":        "string",
					"description": "Optional comment explaining why the alert was dismissed",
					"example":     "This dependency is only used in development and poses no production risk",
					"maxLength":   280,
				},
			},
			"required": []interface{}{"owner", "repo", "alert_number", "state"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"number":            1,
			"state":             "dismissed",
			"dismissed_by":      map[string]interface{}{"login": "octocat"},
			"dismissed_at":      "2024-01-15T12:30:00Z",
			"dismissed_reason":  "tolerable_risk",
			"dismissed_comment": "This dependency is only used in development",
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the alert_number exists. Use list_dependabot_alerts to find valid alert numbers.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and write access to dismiss alerts.",
			},
			{
				"error":    "422 Unprocessable Entity",
				"solution": "When dismissing, ensure dismissed_reason is provided. Check that the state transition is valid.",
			},
		},
		ExtendedHelp: "Updates the state of a Dependabot alert. Use this to dismiss alerts for dependencies that are not exploitable in your context, or to reopen alerts that need attention. Dismissal reasons help document security decisions.",
	}
}

func (h *UpdateDependabotAlertHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")
	alertNumber := extractInt(params, "alert_number")
	state := extractString(params, "state")

	var dismissedReason *string
	var dismissedComment *string

	if reason := extractString(params, "dismissed_reason"); reason != "" {
		dismissedReason = &reason
	}
	if comment := extractString(params, "dismissed_comment"); comment != "" {
		dismissedComment = &comment
	}

	alert, _, err := client.Dependabot.UpdateAlert(ctx, owner, repo, alertNumber, &github.DependabotAlertState{
		State:            state,
		DismissedReason:  dismissedReason,
		DismissedComment: dismissedComment,
	})
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to update Dependabot alert: %v", err)), nil
	}

	data, _ := json.Marshal(alert)
	return NewToolResult(string(data)), nil
}

// ListSecretScanningAlertsHandler handles listing secret scanning alerts
type ListSecretScanningAlertsHandler struct {
	provider *GitHubProvider
}

func NewListSecretScanningAlertsHandler(p *GitHubProvider) *ListSecretScanningAlertsHandler {
	return &ListSecretScanningAlertsHandler{provider: p}
}

func (h *ListSecretScanningAlertsHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "list_secret_scanning_alerts",
		Description: "List secret scanning alerts for exposed secrets like API keys and tokens found in a repository",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"state": map[string]interface{}{
					"type":        "string",
					"description": "Filter alerts by state",
					"enum":        []interface{}{"open", "resolved"},
					"example":     "open",
				},
				"secret_type": map[string]interface{}{
					"type":        "string",
					"description": "Filter by type of secret detected (e.g., 'github_personal_access_token', 'aws_access_key_id')",
					"example":     "github_personal_access_token",
				},
				"resolution": map[string]interface{}{
					"type":        "string",
					"description": "Filter by resolution status",
					"enum":        []interface{}{"false_positive", "wont_fix", "revoked", "used_in_tests"},
					"example":     "revoked",
				},
				"per_page": map[string]interface{}{
					"type":        "integer",
					"description": "Number of alerts to return per page (1-100)",
					"default":     30,
					"minimum":     1,
					"maximum":     100,
					"example":     50,
				},
				"page": map[string]interface{}{
					"type":        "integer",
					"description": "Page number to retrieve (1-based pagination)",
					"default":     1,
					"minimum":     1,
					"example":     1,
				},
			},
			"required": []interface{}{"owner", "repo"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events", "repo"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"alerts": []map[string]interface{}{
				{
					"number":      1,
					"state":       "open",
					"secret_type": "github_personal_access_token",
					"secret":      "ghp_****",
					"created_at":  "2024-01-15T12:00:00Z",
				},
			},
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the repository exists and secret scanning is enabled.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and read access to the repository.",
			},
		},
		ExtendedHelp: "Lists alerts for secrets accidentally committed to the repository. Secret scanning detects tokens, private keys, and other secrets to prevent unauthorized access. Requires secret scanning to be enabled in repository settings.",
	}
}

func (h *ListSecretScanningAlertsHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")

	pagination := ExtractPagination(params)
	opts := &github.SecretScanningAlertListOptions{
		ListOptions: github.ListOptions{
			Page:    pagination.Page,
			PerPage: pagination.PerPage,
		},
	}

	if state := extractString(params, "state"); state != "" {
		opts.State = state
	}
	if secretType := extractString(params, "secret_type"); secretType != "" {
		opts.SecretType = secretType
	}
	if resolution := extractString(params, "resolution"); resolution != "" {
		opts.Resolution = resolution
	}

	alerts, _, err := client.SecretScanning.ListAlertsForRepo(ctx, owner, repo, opts)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to list secret scanning alerts: %v", err)), nil
	}

	data, _ := json.Marshal(alerts)
	return NewToolResult(string(data)), nil
}

// GetSecretScanningAlertHandler handles getting a specific secret scanning alert
type GetSecretScanningAlertHandler struct {
	provider *GitHubProvider
}

func NewGetSecretScanningAlertHandler(p *GitHubProvider) *GetSecretScanningAlertHandler {
	return &GetSecretScanningAlertHandler{provider: p}
}

func (h *GetSecretScanningAlertHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "get_secret_scanning_alert",
		Description: "Get detailed information about a specific secret scanning alert",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"alert_number": map[string]interface{}{
					"type":        "integer",
					"description": "The number that identifies the secret scanning alert",
					"example":     1,
					"minimum":     1,
				},
			},
			"required": []interface{}{"owner", "repo", "alert_number"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events", "repo"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"number":                   1,
			"state":                    "open",
			"secret_type":              "github_personal_access_token",
			"secret_type_display_name": "GitHub Personal Access Token",
			"secret":                   "ghp_****",
			"created_at":               "2024-01-15T12:00:00Z",
			"locations_url":            "https://api.github.com/repos/owner/repo/secret-scanning/alerts/1/locations",
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the alert_number exists. Use list_secret_scanning_alerts to find valid alert numbers.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and read access to the repository.",
			},
		},
		ExtendedHelp: "Retrieves detailed information about a specific secret scanning alert including the type of secret, when it was detected, and its current state. Use list_secret_scanning_locations to find where the secret appears in the repository.",
	}
}

func (h *GetSecretScanningAlertHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")
	alertNumber := int64(extractInt(params, "alert_number"))

	alert, _, err := client.SecretScanning.GetAlert(ctx, owner, repo, alertNumber)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to get secret scanning alert: %v", err)), nil
	}

	data, _ := json.Marshal(alert)
	return NewToolResult(string(data)), nil
}

// UpdateSecretScanningAlertHandler handles updating a secret scanning alert
type UpdateSecretScanningAlertHandler struct {
	provider *GitHubProvider
}

func NewUpdateSecretScanningAlertHandler(p *GitHubProvider) *UpdateSecretScanningAlertHandler {
	return &UpdateSecretScanningAlertHandler{provider: p}
}

func (h *UpdateSecretScanningAlertHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "update_secret_scanning_alert",
		Description: "Update a secret scanning alert to resolve or reopen it with appropriate documentation",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"alert_number": map[string]interface{}{
					"type":        "integer",
					"description": "The number that identifies the secret scanning alert to update",
					"example":     1,
					"minimum":     1,
				},
				"state": map[string]interface{}{
					"type":        "string",
					"description": "New state for the alert",
					"enum":        []interface{}{"open", "resolved"},
					"example":     "resolved",
				},
				"resolution": map[string]interface{}{
					"type":        "string",
					"description": "Resolution type (required when state is 'resolved')",
					"enum":        []interface{}{"false_positive", "wont_fix", "revoked", "used_in_tests"},
					"example":     "revoked",
				},
				"resolution_comment": map[string]interface{}{
					"type":        "string",
					"description": "Optional comment explaining the resolution",
					"example":     "Token has been revoked and rotated with new credentials",
					"maxLength":   280,
				},
			},
			"required": []interface{}{"owner", "repo", "alert_number", "state"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"number":             1,
			"state":              "resolved",
			"resolution":         "revoked",
			"resolved_by":        map[string]interface{}{"login": "octocat"},
			"resolved_at":        "2024-01-15T12:30:00Z",
			"resolution_comment": "Token has been revoked",
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the alert_number exists. Use list_secret_scanning_alerts to find valid alert numbers.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and write access to resolve alerts.",
			},
			{
				"error":    "422 Unprocessable Entity",
				"solution": "When resolving, ensure resolution type is provided. Check that the state transition is valid.",
			},
		},
		ExtendedHelp: "Updates the state of a secret scanning alert. When resolving, indicate whether the secret was revoked, is a false positive, won't be fixed, or is used in tests. Always revoke exposed production secrets immediately.",
	}
}

func (h *UpdateSecretScanningAlertHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")
	alertNumber := int64(extractInt(params, "alert_number"))
	state := extractString(params, "state")

	opts := &github.SecretScanningAlertUpdateOptions{
		State: state,
	}

	if resolution := extractString(params, "resolution"); resolution != "" {
		opts.Resolution = &resolution
	}
	if comment := extractString(params, "resolution_comment"); comment != "" {
		opts.ResolutionComment = &comment
	}

	alert, _, err := client.SecretScanning.UpdateAlert(ctx, owner, repo, alertNumber, opts)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to update secret scanning alert: %v", err)), nil
	}

	data, _ := json.Marshal(alert)
	return NewToolResult(string(data)), nil
}

// ListSecretScanningLocationsHandler handles listing locations for a secret scanning alert
type ListSecretScanningLocationsHandler struct {
	provider *GitHubProvider
}

func NewListSecretScanningLocationsHandler(p *GitHubProvider) *ListSecretScanningLocationsHandler {
	return &ListSecretScanningLocationsHandler{provider: p}
}

func (h *ListSecretScanningLocationsHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "list_secret_scanning_locations",
		Description: "List all file locations where a specific secret was detected in the repository",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"alert_number": map[string]interface{}{
					"type":        "integer",
					"description": "The secret scanning alert number to get locations for",
					"example":     1,
					"minimum":     1,
				},
				"per_page": map[string]interface{}{
					"type":        "integer",
					"description": "Number of locations to return per page (1-100)",
					"default":     30,
					"minimum":     1,
					"maximum":     100,
					"example":     50,
				},
				"page": map[string]interface{}{
					"type":        "integer",
					"description": "Page number to retrieve (1-based pagination)",
					"default":     1,
					"minimum":     1,
					"example":     1,
				},
			},
			"required": []interface{}{"owner", "repo", "alert_number"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"security_events", "repo"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"locations": []map[string]interface{}{
				{
					"type":         "commit",
					"path":         "config/database.yml",
					"start_line":   15,
					"end_line":     15,
					"start_column": 12,
					"end_column":   45,
					"blob_sha":     "abc123def456",
					"commit_sha":   "def456ghi789",
				},
			},
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the alert_number exists. Use list_secret_scanning_alerts to find valid alert numbers.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have the 'security_events' scope and read access to the repository.",
			},
		},
		ExtendedHelp: "Lists all locations in the repository where a specific secret was found. This helps identify all instances that need to be removed or rotated. Each location includes file path, line numbers, and commit information.",
	}
}

func (h *ListSecretScanningLocationsHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")
	alertNumber := int64(extractInt(params, "alert_number"))

	pagination := ExtractPagination(params)
	opts := &github.ListOptions{
		Page:    pagination.Page,
		PerPage: pagination.PerPage,
	}

	locations, _, err := client.SecretScanning.ListLocationsForAlert(ctx, owner, repo, alertNumber, opts)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to list secret scanning locations: %v", err)), nil
	}

	data, _ := json.Marshal(locations)
	return NewToolResult(string(data)), nil
}

// ListSecurityAdvisoriesHandler handles listing security advisories for a repository
type ListSecurityAdvisoriesHandler struct {
	provider *GitHubProvider
}

func NewListSecurityAdvisoriesHandler(p *GitHubProvider) *ListSecurityAdvisoriesHandler {
	return &ListSecurityAdvisoriesHandler{provider: p}
}

func (h *ListSecurityAdvisoriesHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "list_security_advisories",
		Description: "List repository-specific security advisories that have been published by the repository maintainers",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"owner": map[string]interface{}{
					"type":        "string",
					"description": "Repository owner username or organization name (e.g., 'facebook', 'microsoft')",
					"example":     "facebook",
					"pattern":     "^[a-zA-Z0-9][a-zA-Z0-9-]*$",
					"minLength":   1,
					"maxLength":   39,
				},
				"repo": map[string]interface{}{
					"type":        "string",
					"description": "Repository name without the .git extension (e.g., 'react', 'vscode')",
					"example":     "react",
					"pattern":     "^[a-zA-Z0-9._-]+$",
					"minLength":   1,
					"maxLength":   100,
				},
				"state": map[string]interface{}{
					"type":        "string",
					"description": "Filter advisories by state",
					"enum":        []interface{}{"published", "closed", "withdrawn", "draft", "triage"},
					"example":     "published",
				},
				"severity": map[string]interface{}{
					"type":        "string",
					"description": "Filter by severity level",
					"enum":        []interface{}{"critical", "high", "medium", "low"},
					"example":     "high",
				},
				"per_page": map[string]interface{}{
					"type":        "integer",
					"description": "Number of advisories to return per page (1-100)",
					"default":     30,
					"minimum":     1,
					"maximum":     100,
					"example":     50,
				},
				"page": map[string]interface{}{
					"type":        "integer",
					"description": "Page number to retrieve (1-based pagination)",
					"default":     1,
					"minimum":     1,
					"example":     1,
				},
			},
			"required": []interface{}{"owner", "repo"},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{"repo"},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"advisories": []map[string]interface{}{
				{
					"ghsa_id":      "GHSA-xxxx-yyyy-zzzz",
					"cve_id":       "CVE-2024-1234",
					"summary":      "Cross-site scripting vulnerability",
					"description":  "A cross-site scripting vulnerability was found...",
					"severity":     "high",
					"state":        "published",
					"published_at": "2024-01-15T12:00:00Z",
				},
			},
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "404 Not Found",
				"solution": "Verify the repository exists and has security advisories enabled.",
			},
			{
				"error":    "403 Forbidden",
				"solution": "Ensure you have read access to the repository's security advisories.",
			},
		},
		ExtendedHelp: "Lists security advisories created and published by repository maintainers. These advisories document vulnerabilities found in the project and provide guidance for users. Different from Dependabot alerts which track third-party dependencies.",
	}
}

func (h *ListSecurityAdvisoriesHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	owner := extractString(params, "owner")
	repo := extractString(params, "repo")

	pagination := ExtractPagination(params)
	opts := &github.ListRepositorySecurityAdvisoriesOptions{
		ListCursorOptions: github.ListCursorOptions{
			PerPage: pagination.PerPage,
		},
	}

	if state := extractString(params, "state"); state != "" {
		opts.State = state
	}

	// Note: The API doesn't support severity filtering directly,
	// but we keep the parameter for potential client-side filtering
	severityFilter := extractString(params, "severity")

	advisories, _, err := client.SecurityAdvisories.ListRepositorySecurityAdvisories(ctx, owner, repo, opts)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to list security advisories: %v", err)), nil
	}

	// Apply client-side severity filtering if requested
	if severityFilter != "" {
		var filtered []*github.SecurityAdvisory
		for _, advisory := range advisories {
			if advisory.Severity != nil && *advisory.Severity == severityFilter {
				filtered = append(filtered, advisory)
			}
		}
		advisories = filtered
	}

	data, _ := json.Marshal(advisories)
	return NewToolResult(string(data)), nil
}

// ListGlobalSecurityAdvisoriesHandler handles listing global security advisories
type ListGlobalSecurityAdvisoriesHandler struct {
	provider *GitHubProvider
}

func NewListGlobalSecurityAdvisoriesHandler(p *GitHubProvider) *ListGlobalSecurityAdvisoriesHandler {
	return &ListGlobalSecurityAdvisoriesHandler{provider: p}
}

func (h *ListGlobalSecurityAdvisoriesHandler) GetDefinition() ToolDefinition {
	return ToolDefinition{
		Name:        "list_global_security_advisories",
		Description: "Search the GitHub Advisory Database for security vulnerabilities across all open source software",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"ghsa_id": map[string]interface{}{
					"type":        "string",
					"description": "Filter by GitHub Security Advisory ID (e.g., 'GHSA-xxxx-yyyy-zzzz')",
					"example":     "GHSA-jfh8-c2jp-5v3q",
					"pattern":     "^GHSA-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}$",
				},
				"cve_id": map[string]interface{}{
					"type":        "string",
					"description": "Filter by CVE ID (e.g., 'CVE-2024-1234')",
					"example":     "CVE-2024-1234",
					"pattern":     "^CVE-\\d{4}-\\d{4,}$",
				},
				"ecosystem": map[string]interface{}{
					"type":        "string",
					"description": "Filter by package ecosystem",
					"enum":        []interface{}{"npm", "pip", "maven", "nuget", "composer", "go", "rust", "erlang", "rubygems", "pub", "docker", "github-actions"},
					"example":     "npm",
				},
				"severity": map[string]interface{}{
					"type":        "string",
					"description": "Filter by severity level",
					"enum":        []interface{}{"critical", "high", "medium", "low"},
					"example":     "critical",
				},
				"cwes": map[string]interface{}{
					"type":        "array",
					"description": "Filter by Common Weakness Enumeration IDs",
					"items": map[string]interface{}{
						"type":    "string",
						"example": "CWE-79",
					},
				},
				"is_withdrawn": map[string]interface{}{
					"type":        "boolean",
					"description": "Include withdrawn advisories in results",
					"default":     false,
					"example":     false,
				},
				"affects": map[string]interface{}{
					"type":        "array",
					"description": "Filter by affected package names",
					"items": map[string]interface{}{
						"type":    "string",
						"example": "lodash",
					},
				},
				"published": map[string]interface{}{
					"type":        "string",
					"description": "Filter by published date (YYYY-MM-DD format)",
					"example":     "2024-01-15",
					"pattern":     "^\\d{4}-\\d{2}-\\d{2}$",
				},
				"updated": map[string]interface{}{
					"type":        "string",
					"description": "Filter by last updated date (YYYY-MM-DD format)",
					"example":     "2024-01-15",
					"pattern":     "^\\d{4}-\\d{2}-\\d{2}$",
				},
				"per_page": map[string]interface{}{
					"type":        "integer",
					"description": "Number of advisories to return per page (1-100)",
					"default":     30,
					"minimum":     1,
					"maximum":     100,
					"example":     50,
				},
			},
		},
		Metadata: map[string]interface{}{
			"category":    "security",
			"scopes":      []string{},
			"rateLimit":   "standard",
			"destructive": false,
		},
		ResponseExample: map[string]interface{}{
			"advisories": []map[string]interface{}{
				{
					"ghsa_id":      "GHSA-jfh8-c2jp-5v3q",
					"cve_id":       "CVE-2024-1234",
					"summary":      "Prototype Pollution in lodash",
					"description":  "Versions of lodash prior to 4.17.21 are vulnerable...",
					"severity":     "high",
					"published_at": "2024-01-01T00:00:00Z",
					"updated_at":   "2024-01-15T12:00:00Z",
					"references":   []map[string]interface{}{{"url": "https://nvd.nist.gov/vuln/detail/CVE-2024-1234"}},
				},
			},
		},
		CommonErrors: []map[string]interface{}{
			{
				"error":    "422 Unprocessable Entity",
				"solution": "Check that filter parameters use valid values from the enums provided.",
			},
			{
				"error":    "400 Bad Request",
				"solution": "Ensure date formats are YYYY-MM-DD and IDs follow the correct pattern.",
			},
		},
		ExtendedHelp: "Searches GitHub's global Advisory Database which aggregates security vulnerability information from multiple sources. Use this to check if specific packages or technologies have known vulnerabilities. No authentication required for public advisories.",
	}
}

func (h *ListGlobalSecurityAdvisoriesHandler) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {
	client, ok := GetGitHubClientFromContext(ctx)
	if !ok {
		return NewToolError("GitHub client not found in context"), nil
	}

	opts := &github.ListGlobalSecurityAdvisoriesOptions{}

	if ghsaID := extractString(params, "ghsa_id"); ghsaID != "" {
		opts.GHSAID = &ghsaID
	}
	if cveID := extractString(params, "cve_id"); cveID != "" {
		opts.CVEID = &cveID
	}
	if ecosystem := extractString(params, "ecosystem"); ecosystem != "" {
		opts.Ecosystem = &ecosystem
	}
	if severity := extractString(params, "severity"); severity != "" {
		opts.Severity = &severity
	}
	if isWithdrawn, ok := params["is_withdrawn"].(bool); ok {
		opts.IsWithdrawn = &isWithdrawn
	}

	// Handle pagination
	if perPage := extractInt(params, "per_page"); perPage > 0 {
		opts.PerPage = perPage
	}

	advisories, _, err := client.SecurityAdvisories.ListGlobalSecurityAdvisories(ctx, opts)
	if err != nil {
		return NewToolError(fmt.Sprintf("Failed to list global security advisories: %v", err)), nil
	}

	data, _ := json.Marshal(advisories)
	return NewToolResult(string(data)), nil
}
